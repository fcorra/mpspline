primpke@clusterlist[87]
sref@clusterlist[87]
bol.vec
primpke@clusternames[primpke@clusterlist[44]]
sref@clusternames[sref@clusterlist[44]]
primpke@clusternames[primpke@clusterlist[45]]
sref@clusternames[sref@clusterlist[45]]
primpke@clusternames[primpke@clusterlist[30]]
sref@clusternames[sref@clusterlist[30]]
# Remove 'rubber type' from primpke
sref <- primpke
bol.vec <- sref@clusterlist %in% c(1:15,17:27,30,31)
sref@Spectra <- sref@Spectra[bol.vec, ]
sref@clusternames <- sref@clusternames[c(1:15,17:27,30,31)]
sref@clusterlist <- sref@clusterlist[bol.vec]
sref@clusterlist <- sapply(sref@clusterlist, function(x){
if(x %in% seq(17,27)){
x <- x-1L
}else if(x %in% seq(30,31)){
x <- x -2L
}else {
x
}
})
sref@substances <- sref@substances[bol.vec]
#rm(bol.vec)
save(sref, "~/Documents/tmp/src-anunna/tools/spectral-library.rdata")
save(sref, file="~/Documents/tmp/src-anunna/tools/spectral-library.rdata")
load("~/Documents/tmp/src-anunna/tools/spectral-library.rdata")
library(uFTIR)
library(signal)
par(las = 1)
#rm(list=ls())
pe <- tile_read("~/Documents/sxlt/data/validation/pe_c_tile.bsp")
pe <- tile_read("~/Documents/sxlt/data/validation/pe_c_tile.bsp")
pe.sam <- tile_base_corr(pe)
pe.sam <- wavealign(pe.sam, sref)
pe.sam <- preprocess(pe.sam, function(x){sgolayfilt(x, 3,5,1,1)})
pe.sam <- tile_sam(pe.sam, 1)
dim(pe.sam@raw_sam)
x <- pe.sam@raw_sam[24,90,]
grep(min(x), x)
pe.sam@substances[24,90,1]
min(x)
mean(pe.sam@raw_sam)
min(pe.sam@raw_sam)
max(pe.sam@raw_sam)
library(uFTIR)
# Remove 'rubber type' from primpke
sref <- primpke
bol.vec <- sref@clusterlist %in% c(1:15,17:27,30,31)
sref@Spectra <- sref@Spectra[bol.vec, ]
sref@clusternames <- sref@clusternames[c(1:15,17:27,30,31)]
sref@clusterlist <- sref@clusterlist[bol.vec]
sref@clusterlist <- sapply(sref@clusterlist, function(x){
if(x %in% seq(17,27)){
x <- x-1L
}else if(x %in% seq(30,31)){
x <- x -2L
}else {
x
}
})
sref@substances <- sref@substances[bol.vec]
sref@clusternames
plastic <- c(TRUE,TRUE,TRUE,TRUE,TRUE,TRUE,TRUE,TRUE,
FALSE,TRUE,TRUE,TRUE,FALSE,FALSE,FALSE,TRUE,
TRUE,TRUE,FALSE,TRUE,TRUE,TRUE,TRUE,TRUE,
TRUE,TRUE,TRUE,TRUE,TRUE,FALSE,FALSE,TRUE)
sref@clusternames[plastic]
sref@clusternames
C(T,T,T,T,T,T,T,T,F,T,T,T,F,F,F,T,T,F,T,T,T,T,T,T,T,T,F,F)
c(T,T,T,T,T,T,T,T,F,T,T,T,F,F,F,T,T,F,T,T,T,T,T,T,T,T,F,F)
plastic <- c(TRUE,TRUE,TRUE,TRUE,TRUE,TRUE,TRUE,TRUE,
FALSE,TRUE,TRUE,TRUE,FALSE,FALSE,FALSE,
TRUE,TRUE,FALSE,TRUE,TRUE,TRUE,TRUE,TRUE,
TRUE,TRUE,TRUE,FALSE,FALSE)
sref@clusternames[plastic]
primpke@clusternames
q()
mosaic_compose
library(uFTIR)
mosaic_compos
mosaic_compose
sam_write()
sam_write
clipper
mask_sam <- function(x, threshold = 1.1){
# x = raw.sam
out <- array(NA, dim = dim(x)[1:2])
for(i in 1:nrow(x)){
for(j in 1:ncol(x)){
out[i,j] <- min(x[i,j,])
}
}
out[out > threshold] <- NA
}
source('~/Documents/mppl/src-anunna/R/step-one.r')
jout <- mask_sam(x.sam@raw_sam, 1.1)
xycord <- expand.grid(seq(1,128), seq(1,128))
plot(xycord[,2]~xycord[,1], col = ifelse(is.na(jout), "blue", "red"), pch =15)
is.na(jout)
sum(jout == NA)
jout == NA
jout
jout <- matrix(rnorm(100),10,10)
jout
jout > 0
jout[jout > 0]
jout[jout > 0] <- NA
jout
jout <- mask_sam(x.sam@raw_sam, 1.1)
jout
x <- x.sam@raw_sam
# x = raw.sam
out <- array(NA, dim = dim(x)[1:2])
dim(out)
nrow(x)
ncol(x)
i <- 1
j <- 1
min(x[i,j,])
out[i,j]
for(i in 1:nrow(x)){
for(j in 1:ncol(x)){
out[i,j] <- min(x[i,j,])
}
}
dim(out)
out > 1.1
out[out > threshold]
out[out > 1.1]
out[out > 1.1] <- NA
out
dim(out)
mask_sam <- function(x, threshold = 1.1){
# x = raw.sam
out <- array(NA, dim = dim(x)[1:2])
for(i in 1:nrow(x)){
for(j in 1:ncol(x)){
out[i,j] <- min(x[i,j,])
}
}
out[out > threshold] <- NA
out
}
jout <- mask_sam(x.sam@raw_sam, 1.1)
xycord <- expand.grid(seq(1,128), seq(1,128))
plot(xycord[,2]~xycord[,1], col = ifelse(is.na(jout), "blue", "red"), pch =15)
out <- array(NA, dim = dim(x.sam@raw_sam)[1:2])
for(i in 1:nrow(x.sam@raw_sam)){
for(j in 1:ncol(x.sam@raw_sam)){
out[i,j] <- min(x.sam@raw_sam[i,j,])
}
}
xycord <- expand.grid(seq(1,128), seq(1,128))
plot(xycord[,2]~xycord[,1], col = ifelse(out < 1.1, "red", "blue"), pch =15)
()
q()
i <- out-8222.csv
unlist(strsplit(i, "[-\\.]"))[2]
i <- "out-8222.csv"
unlist(strsplit(i, "[-\\.]"))[2]
q()
q
()
q()
q()
install.packages("rhub")
q()
runif(1,0,10)
runif(1,0,10)
runif(1,0,10)
runif(1,0,10)
runif(1,0,10)
runif(1,0,10)
runif(1,0,10)
runif(1,0,10)
runif(1,0,10)
runif(1,0,10)
runif(1,0,10)
runif(1,0,10)
runif(1,0,10)
runif(1,0,10)
runif(1,0,10)
runif(1,0,10)
runif(1,0,10)
runif(1,0,10)
runif(1,0,10)
runif(1,0,10)
runif(1,0,10)
runif(1,0,10)
runif(1,0,10)
runif(1,0,10)
runif(1,0,10)
runif(1,0,10)
runif(1,0,10)
runif(1,0,10)
runif(1,0,10)
runif(1,0,10)
runif(1,0,10)
runif(1,0,10)
runif(1,0,10)
runif(1,0,10)
runif(1,0,10)
runif(1,0,10)
runif(1,0,10)
runif(1,0,10)
set.seed(1)
runif(1,0,10)
runif(1,0,10)
runif(1,0,10)
load ("~/Documents/lrrh/hpc/data/write/minterp.rdata")
err.interp <- inter_out$err.interp
varselect.interp <- inter_out$varselect.interp
l <- length(varselect.interp)
varselect.interp
k <- length(err.interp)
library(randomForest)
?randomForest
q()
q()
?write
q()
update.packages()
y
library(raster)
help(package=raster)
b <- brick(system.file("external/rlogo.grd", package="raster"))
plot(b)
str(b)
nlayers(b)
b[1]
b[1][1]
b$red$red$red$red
b[1]
as.matrix(b[1])
as.matrix(b)
dim(b)
class(b)
b[,,1]
c <- b
rm(c)
z <- b
z[,,1][z[,,1] == 255] <- NA
z[,,1 == 255] <- NA
z[,,1][z[,,1] == 255]
z[,,1][z[,,1] != 255]
z[,,1][z[,,1] == 255] <- 1
z[,,1][z[,,1] != 255]
length(z[,,1][z[,,1] != 255])
length(z[,,1][z[,,1] == 255])
length(z[,,1][!is.na(z[,,1])])
length(z[,,1])
z[,,1][!is.na(z[,,1])] <- 1
z[,,1][!is.na(z[,,1])]
z[,,1][is.na(z[,,1])]
ha <- 10
ha <- 11
ja
ha
ha <- matrix(rnorm(100), 10, 10)
ha
ha[ha < 0] <- N
ha[ha < 0] <- NA
ha
?matrix
?array
array(rnorm(1000), dim = c(10,10,10))
ha <- array(rnorm(1000), dim = c(10,10,10))
ha[,,1]
ha[,,1][ha[,,1] < 0] <- NA
ha[,,1]
dim(ha)
ha[,,10]
10*10*10
for (i in 1:dim (ha)[3]) {
ha[,,i][ha[,,i] < 0] <- NA
}
ha[,,3]
# Habría que hacer lo mismo para un raster brick
library(raster)
b <- brick(system.file("external/rlogo.grd", package="raster"))
dim(b)
for ( i in 1:dim(b)[3] ) {
b[,,i][ !is.na (b[,,i]) ] <- 1
}
# Habría que hacer lo mismo para un raster brick
library(raster)
b <- brick(system.file("external/rlogo.grd", package="raster"))
plot(b)
b[,,i][ is.na (b[,,i]) ]
b[,,i][ !is.na (b[,,i]) ]
b[,,i][ !is.na (b[,,i]) ] <- 76
NA * 85
?reclassify
b[1,2,3]
b[1,2,1]
b[2,,1]
b[2,1,1]
b[2,1,1,1]
dim(b)
plot(b)
b[75,100,]
b[75,100][1]
b[][1]
b[,,][1]
b[,,][4]
b[,,][100]
b[,,][]
b[1,1,3][]
b[1,1,3,4]
b[]
?`RasterBrick-class`
?extract
x <- as.array(b)
x[1,1,]
x[1,1,1]
b[1,1,1]
b[333,1,1]
x[333,,]
b[1,1,1]
x[1,1,]
b[1,1,]
b[77,101,3]
x[77,101,3]
x[77,101,2]
x[77,101,1]
x[55,88,1]
b[55,88,1]
b[55,88][1]
b[55,88][2]
b[55,88][3]
b[,,][3]
b[,,]
b == 100
b[,,] == 100
sum(b[,,] == 100)
b <- brick(system.file("external/rlogo.grd", package="raster"))
for ( i in 1:dim(b)[3] ) {
b[ !is.na ( b[,,] ) ] <- 1
}
plot(b)
plot(b[3])
plot(b)
x <- b$red
b$red == b[1]
b$red == b[,,1]
b$red == b[,,][1]
as.matrix(b$red) == as.matrix(b[,,][1])
all.equal(b$red, b[1])
all.equal(b$red, b[,,][1])
all.equal(b$red, b[,][1])
all.equal(b$red, b[][1])
all.equal(b$red, b[1])
b[,,]
all.equal(b$red, b$red)
b <- brick(system.file("external/rlogo.grd", package="raster"))
for ( i in 1:dim(b)[3] ) {
b[ !is.na ( b ) ] <- 1
}
plot(b)
all.equal(b$red, b[[1]])
library(raster)
b <- brick(system.file("external/rlogo.grd", package="raster"))
for ( i in 1:dim(b)[3] ) {
b[ !is.na ( b ) ] <- 1
}
x <- b[[1]]
for ( i in 2:dim(b)[3] ) {
x <- x * b[[i]]
}
plot(x)
# Si tengo un array de tres dimensiones
y <- array(rnorm(1000), dim = c(10,10,10))
# y quiero reemplazar todos los menores de uno de la primera capa por NA
y[,,1][y[,,1] < 0] <- NA
# Para hacerlo de una en todas las capas
for (i in 1:dim (y)[3]) {
y[,,i][y[,,i] < 0] <- NA
}
# Listo, por ejemplo:
y[,,3]
# Si tengo un array de tres dimensiones
y <- array(rnorm(1000), dim = c(10,10,10))
y[,,1] < 0 <- NA
y[y[,,1] < 0] <- NA
y[,,1]
y <- array(rnorm(1000), dim = c(10,10,10))
# y quiero reemplazar todos los menores de uno de la primera capa por NA
y[y[,,1] < 0] <- NA
# Para hacerlo de una en todas las capas
for (i in 1:dim (y)[3]) {
y[y[,,i] < 0] <- NA
}
# Listo, por ejemplo:
y[,,3]
# Si tengo un array de tres dimensiones
y <- array(rnorm(1000), dim = c(10,10,10))
# y quiero reemplazar todos los menores de uno de la primera capa por NA
y[,,1][y[,,1] < 0] <- NA
# Para hacerlo de una en todas las capas
for (i in 1:dim (y)[3]) {
y[,,i][y[,,i] < 0] <- NA
}
# Listo, por ejemplo:
y[,,3]
set.seed(4)
# Si tengo un array de tres dimensiones
y <- array(rnorm(1000), dim = c(10,10,10))
# y quiero reemplazar todos los menores de uno de la primera capa por NA
y[,,1][y[,,1] < 0] <- NA
# Para hacerlo de una en todas las capas
for (i in 1:dim (y)[3]) {
y[,,i][y[,,i] < 0] <- NA
}
# Listo, por ejemplo:
y[,,3]
set.seed(4)
# Si tengo un array de tres dimensiones
y <- array(rnorm(1000), dim = c(10,10,10))
# y quiero reemplazar todos los menores de uno de la primera capa por NA
y[,,1][y[,,1] < 0] <- NA
# Para hacerlo de una en todas las capas
for (i in 1:dim (y)[3]) {
y[,,i][y[,,i] < 0] <- NA
}
# Listo, por ejemplo:
y[,,3]
set.seed(4)
# Si tengo un array de tres dimensiones
y <- array(rnorm(1000), dim = c(10,10,10))
# y quiero reemplazar todos los menores de uno de la primera capa por NA
y[,,1][y[,,1] < 0] <- NA
# Para hacerlo de una en todas las capas
for (i in 1:dim (y)[3]) {
y[,,i][y[,,i] < 0] <- NA
}
# Listo, por ejemplo:
y[,,3]
set.seed(4)
# Si tengo un array de tres dimensiones
y <- array(rnorm(1000), dim = c(10,10,10))
# y quiero reemplazar todos los menores de uno de la primera capa por NA
y[,,1][y[,,1] < 0] <- NA
# Para hacerlo de una en todas las capas
for (i in 1:dim (y)[3]) {
y[,,i][y[,,i] < 0] <- NA
}
# Listo, por ejemplo:
y[,,3]
set.seed(4)
# Si tengo un array de tres dimensiones
y <- array(rnorm(1000), dim = c(10,10,10))
# y quiero reemplazar todos los menores de uno de la primera capa por NA
y[,,1][y[,,1] < 0] <- NA
# Para hacerlo de una en todas las capas
for (i in 1:dim (y)[3]) {
y[,,i][y[,,i] < 0] <- NA
}
# Listo, por ejemplo:
y[,,3]
set.seed(4)
# Si tengo un array de tres dimensiones
y <- array(rnorm(1000), dim = c(10,10,10))
# y quiero reemplazar todos los menores de uno de la primera capa por NA
y[,,1][y[,,1] < 0] <- NA
# Para hacerlo de una en todas las capas
for (i in 1:dim (y)[3]) {
y[,,i][y[,,i] < 0] <- NA
}
# Listo, por ejemplo:
y[,,3]
library(raster)
b <- brick(system.file("external/rlogo.grd", package="raster"))
b[ !is.na ( b ) ] <- 1
x <- b[[1]]
for ( i in 2:dim(b)[3] ) {
x <- x * b[[i]]
}
plot(x)
plot(b)
?extract
?expand.grid
expand.grid(x = c(-1,0,1), y = c(-1,0,1))
x <- as.matrix(expand.grid(x = c(-1,0,1), y = c(-1,0,1)))
class)x
class(x)
x
q()
library(uFTIR)
detach("package:uFTIR", unload = TRUE)
remove.packages("uFTIR", lib="~/R/x86_64-pc-linux-gnu-library/3.5")
q()
q()
an.omit(matrix(c(NA, 2, 3, NA), nrow = 2))
na.omit(matrix(c(NA, 2, 3, NA), nrow = 2))
matrix(c(NA, 2, 3, NA), nrow = 2)
matrix(c(NA, 2, 3, NA, 1, 2), nrow = 3)
cro <- matrix(c(NA, 2, 3, NA, 1, 2), nrow = 3)
na.omit(cro)
cro <- matrix(c(NA, 2, 3, NA, 1, 2), nrow = 3, byrow = FALSE)
na.omit(cro)
cro
cro <- matrix(c(NA, 2, 3, NA, 1, 2), nrow = 3, byrow = TRUE)
cro
na.omit(cro)
install.packages("aqp")
setwd("~/Documents/fao/suelosalino/src/include/")
setwd("~/Documents/fao/suelosalino/src/include/mpspline/")
package.skeleton(name = "mpspline")
?package.skeleton
